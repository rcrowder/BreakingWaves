/*
 * An implementation of:
 *
 * A simple model of ocean waves. Alain Fournier and William T. Reeves. 1986.
 *
 * In Proceedings of the 13th annual conference on Computer graphics and 
 * interactive techniques (SIGGRAPH '86),
 * David C. Evans and Russell J. Athay (Eds.). ACM, New York, NY, USA, 75-84.
 *
 * DOI: http://dx.doi.org/10.1145/15922.15894
 *
 * Abstract:
 *
 * We present a simple model for the surface of the ocean, suitable for the
 * modeling and rendering of most common waves where the disturbing force is
 * from the wind and the restoring force from gravity.
 * It is based on the Gerstner, or Rankine, model where particles of water
 * describe circular or elliptical stationary orbits. The model can easily
 * produce realistic waves shapes which are varied according to the
 * parameters of the orbits. The surface of the ocean floor affects the
 * refraction and the breaking of waves on the shore. The model can also
 * determine the position, direction, and speed of breakers.
 * The ocean surface is modeled as a parametric surface, permitting the use
 * of traditional rendering methods, including ray-tracing and adaptive
 * subdivision. Animation is easy, since time is built into the model. The
 * foam generated by the breakers is modeled by particle systems whose
 * direction, speed and life expectancy is given by the surface model.
 * To give designers control over the shape of the ocean, the model of the
 * overall surface includes multiple trains of waves, each with its own set
 * of parameters and optional stochastic elements. The overall "randomness"
 * and "short-crestedness" of the ocean is achieved by a combination of
 * small variations within a train and large variations between trains.
 * 
 */

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEditor;


[ExecuteInEditMode]
[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class SeaSurface : MonoBehaviour
{
    public int Width;
    public int Depth;

    private Mesh surfaceMesh;

    private Vector3[] vertices;
    private Vector3[] original;
    private Vector3[] offsets;
    private float[]   restDepth;
    private int[]     triangles;
    private Vector2[] uv;
    private Vector3[] normals;
    private Vector4[] tangents;

    private float time;

    private Toggle showVertices;
    private bool enableUpdateInEditor;

    // Variable naming according to paper Glossary (section 10):
    //                                 Meaning          Units           Remarks
    private float H;                // Height of wave   meter
    private float L;                // Wave length      meters
    private float d;                // Steepness        -               d = H / L
    private float r;                // Radius of orbit  meter           H = 2 * r
    private float T;                // Period           second
    private float K;                // Wave number      radian/meter    L = 2PI / K
    private float w;                // Angular speed    radian/second   T = 2PI / w
    private float c;                // Phase speed      radian/second   c = L / T
    private float h;                // Depth            meter
    //private Vector3 g;              // Gravity vector   meter/second^2  vector
    //private Vector3 U;              // Group velocity   meter/second    vector
    //private Vector3 V;              // Wind speed       meter/second    vector
    private float t;                // Time             second
    private float gamma;            // Slope of bottom  -               In direction of wave
    private float theta;            // Phase angle      radian
    private float lambda;           // Wind factor      radian/meter second
    private float D;                // Depth effect     radian

    void Start()
    {
        // Whether the SeaSurface mesh update will in editor mode
        enableUpdateInEditor = false;

        // Find the Show Vertices UI Toggle object
        showVertices = GameObject.Find("Show Vertices").GetComponent<Toggle>();

        time = 0f;

        // Note: K * r must be (0, 1] (see Figure 4)
        //       >1 leads to self intersection
        float kr = 0.7f;

        // Gravity
        float g = 9.8f;

        // Define wind speed (m/s)
        float V = 5f;

        // Average height of highest 1/3 of waves ala [Kins84]
        float H_third = 0.007065f * Mathf.Pow(V, 2.5f);

        H = H_third * 3;

        r = H / 2f;
        K = kr / r;

        w = (g / V) * Mathf.Sqrt(2f / 3f);
        T = (Mathf.PI * 2f) / w;

        L = (g * (T * T)) / (2f * Mathf.PI);
        c = (g * T) / (2f * Mathf.PI);

        K = w / c;

        d = H / L;

        /*
        r = 2f;                     // Radius of orbit
        K = kr / r;                 // Wave number

        float s = 2f;               // Speed factor
        w = (2f * Mathf.PI) / s;    // Angular speed
        c = w / K;                  // Phase speed

        T = (2f * Mathf.PI) / w;    // Period
        L = (2f * Mathf.PI) / K;    // Wave length

        H = 2f * r;                 // Height of wave
        d = H / L;                  // Steepness
        */

        if (surfaceMesh == null)
        {
            surfaceMesh = new Mesh();
            surfaceMesh.name = "Sea Surface";

            GetComponent<MeshFilter>().mesh = surfaceMesh;
        }

        BuildMesh();
    }

    private void Awake()
    {
        Start();
    }

    private void BuildMesh()
    {
        if (Width <= 0 || Depth <= 0)
            return;

        if (vertices != null)
        {
            vertices = null;
            original = null;
            offsets = null;
            restDepth = null;

            triangles = null;

            uv = null;
            normals = null;
            tangents = null;
        }

        vertices = new Vector3[(Width + 1) * (Depth + 1)];
        original = new Vector3[vertices.Length];
        offsets = new Vector3[vertices.Length];
        restDepth = new float[vertices.Length];

        triangles = new int[Width * Depth * 6];

        uv = new Vector2[vertices.Length];
        normals = new Vector3[vertices.Length];
        tangents = new Vector4[vertices.Length];

        Vector3 normal = Vector3.up;
        Vector4 tangent = new Vector4(1f, 0f, 0f, -1f);

        // Create a flat mesh in the XZ plane
        for (int i = 0, z = 0; z <= Depth; z++)
        {
            for (int x = 0; x <= Width; x++, i++)
            {
                vertices[i] = new Vector3(x, 0f, z);
                original[i] = new Vector3(x, 0f, z);

                offsets[i] = new Vector3(0f, 0f, 0f);

                float height = 9999f;

                if (Physics.Raycast(vertices[i], -Vector3.up, out RaycastHit hit))
                    height = hit.distance;

                restDepth[i] = height;

                // No tiling, [0, 1] range for u & v coords
                uv[i] = new Vector2((float)x / Width, (float)z / Depth);

                normals[i] = normal;
                tangents[i] = tangent;
            }
        }

        for (int ti = 0, vi = 0, z = 0; z < Depth; z++, vi++)
        {
            for (int x = 0; x < Width; x++, ti += 6, vi++)
            {
                triangles[ti] = vi;
                triangles[ti + 3] = triangles[ti + 2] = vi + 1;
                triangles[ti + 4] = triangles[ti + 1] = vi + Width + 1;
                triangles[ti + 5] = vi + Width + 2;
            }
        }
        
        UpdateMesh();
    }

    private void UpdateMesh()
    {
        if (surfaceMesh == null || vertices == null)
            return;

        surfaceMesh.Clear();

        surfaceMesh.vertices = vertices;
        surfaceMesh.triangles = triangles;
        surfaceMesh.uv = uv;
        surfaceMesh.normals = normals;
        surfaceMesh.tangents = tangents;

        surfaceMesh.RecalculateBounds();
        surfaceMesh.RecalculateNormals();
    }

    void Update()
    {
#if UNITY_EDITOR
        if (EditorApplication.isPlayingOrWillChangePlaymode == false &&
            enableUpdateInEditor == false)
            return;
#endif

        if (surfaceMesh == null || vertices == null)
            return;

        float dt = Time.deltaTime;

        time += dt;

        Vector3 normal = new Vector3();
        Vector3 tangent = new Vector3();

        float shape = 2.5f;

        // Gerstner's or Ranke waves (aka trochoidal waves)
        for (int i = 0; i < vertices.Length; i++)
        {
            float dz = vertices[i].y - original[i].y;
            float kludge = shape * dz * dt;

            float phase = (K * original[i].z) - (w * time) - kludge;

            offsets[i].z =  1f * r * Mathf.Sin(phase);
            offsets[i].y = -1f * r * Mathf.Cos(phase);

            vertices[i] = original[i] + offsets[i];

            tangent.Set(1f - K * r * Mathf.Sin(phase), K * r * Mathf.Cos(phase), 0f);
            tangents[i] = Vector3.Normalize(tangent);

            normal.Set(-tangent.y, tangent.x, 0f);
            normals[i] = normal;
        }

        UpdateMesh();
    }

#if UNITY_EDITOR
    void OnEnable()
    {
        if (enableUpdateInEditor)
            EditorApplication.update += Update;
    }

    void OnDisable()
    {
        if (enableUpdateInEditor)
            EditorApplication.update -= Update;
    }
#endif

    private void OnDrawGizmos()
    {
        if (vertices == null || showVertices == null)
            return;

        if (!showVertices.isOn)
            return;

        Gizmos.color = Color.black;

        for (int i = 0; i < vertices.Length; i++)
        {
            Gizmos.DrawSphere(vertices[i], 0.1f);
        }
    }
}
